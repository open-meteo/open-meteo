// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum com_openmeteo_api_result_Unit: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case celsius = 1
  case fahrenheit = 2
  case kelvin = 3
  case kmh = 4
  case mph = 5
  case knots = 6
  case ms = 7
  case msNotUnitConverted = 8
  case millimeter = 9
  case centimeter = 10
  case inch = 11
  case feet = 12
  case meter = 13
  case gpm = 14
  case percent = 15
  case hectoPascal = 16
  case pascal = 17
  case degreeDirection = 18
  case wmoCode = 19
  case wattPerSquareMeter = 20
  case kilogramPerSquareMeter = 21
  case gramPerKilogram = 22
  case perSecond = 23
  case second = 24
  case qubicMeterPerQubicMeter = 25
  case qubicMeterPerSecond = 26
  case kiloPascal = 27
  case megaJoulesPerSquareMeter = 28
  case joulesPerKilogram = 29
  case hours = 30
  case iso8601 = 31
  case unixtime = 32
  case microgramsPerQuibicMeter = 33
  case grainsPerQuibicMeter = 34
  case dimensionless = 35
  case dimensionlessInteger = 36
  case eaqi = 37
  case usaqi = 38
  case gddCelsius = 39
  case fraction = 40

  public static var max: com_openmeteo_api_result_Unit { return .fraction }
  public static var min: com_openmeteo_api_result_Unit { return .celsius }
}


public enum com_openmeteo_api_result_Aggregation: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case minimum = 1
  case maximum = 2
  case mean = 3
  case median = 4
  case p10 = 5
  case p25 = 6
  case p75 = 7
  case p90 = 8
  case dominant = 9
  case sum = 10

  public static var max: com_openmeteo_api_result_Aggregation { return .sum }
  public static var min: com_openmeteo_api_result_Aggregation { return .undefined }
}


public enum com_openmeteo_api_result_VariableType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case temperature = 1
  case cloudcover = 2
  case cloudcoverLow = 3
  case cloudcoverMid = 4
  case cloudcoverHigh = 5
  case pressureMsl = 6
  case relativehumidity = 7
  case precipitation = 8
  case precipitationProbability = 9
  case weathercode = 10
  case soilTemperature = 11
  case soilMoisture = 12
  case snowDepth = 13
  case snowHeight = 14
  case sensibleHeatflux = 15
  case latentHeatflux = 16
  case showers = 17
  case rain = 18
  case windgusts = 19
  case freezinglevelHeight = 20
  case dewpoint = 21
  case diffuseRadiation = 22
  case directRadiation = 23
  case apparentTemperature = 24
  case windspeed = 25
  case winddirection = 26
  case directNormalIrradiance = 27
  case evapotranspiration = 28
  case et0FaoEvapotranspiration = 29
  case vaporPressureDeficit = 30
  case shortwaveRadiation = 31
  case snowfall = 32
  case surfacePressure = 33
  case terrestrialRadiation = 34
  case terrestrialRadiationInstant = 35
  case shortwaveRadiationInstant = 36
  case diffuseRadiationInstant = 37
  case directRadiationInstant = 38
  case directNormalIrradianceInstant = 39
  case visibility = 40
  case cape = 41
  case uvIndex = 42
  case uvIndexClearSky = 43
  case isDay = 44
  case growingDegreeDays = 45
  case leafWetnessProbability = 46
  case soilMoistureIndex = 47
  case geopotentialHeight = 48
  case verticalVelocity = 49
  case daylightDuration = 50
  case sunrise = 51
  case sunset = 52
  case pm10 = 53
  case pm25 = 54
  case dust = 55
  case aerosolOpticalDepth = 56
  case carbonMonoxide = 57
  case nitrogenDioxide = 58
  case ammonia = 59
  case ozone = 60
  case sulphurDioxide = 61
  case alderPollen = 62
  case birchPollen = 63
  case grassPollen = 64
  case mugwortPollen = 65
  case olivePollen = 66
  case ragweedPollen = 67
  case waveHeight = 68
  case wavePeriod = 69
  case waveDirection = 70
  case windWaveHeight = 71
  case windWavePeriod = 72
  case windWavePeakPeriod = 73
  case windWaveDirection = 74
  case swellWaveHeight = 75
  case swellWavePeriod = 76
  case swellWavePeakPeriod = 77
  case swellWaveDirection = 78
  case riverDischarge = 79

  public static var max: com_openmeteo_api_result_VariableType { return .riverDischarge }
  public static var min: com_openmeteo_api_result_VariableType { return .undefined }
}


public enum com_openmeteo_api_result_Model: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case bestMatch = 1
  case gfsSeamless = 2
  case gfsGlobal = 3
  case gfsHrrr = 4
  case meteofranceSeamless = 5
  case meteofranceArpegeWorld = 6
  case meteofranceArpegeEurope = 7
  case meteofranceAromeFrance = 8
  case meteofranceAromeFranceHd = 9
  case jmaSeamless = 10
  case jmaMsm = 11
  case jmsGsm = 12
  case jmaGsm = 13
  case gemSeamless = 14
  case gemGlobal = 15
  case gemRegional = 16
  case gemHrdpsContinental = 17
  case iconSeamless = 18
  case iconGlobal = 19
  case iconEu = 20
  case iconD2 = 21
  case ecmwfIfs04 = 22
  case metnoNordic = 23
  case camsGlobal = 24
  case camsEurope = 25
  case cmccCm2Vhr4 = 26
  case fgoalsF3HHighressst = 27
  case fgoalsF3H = 28
  case hiramSitHr = 29
  case mriAgcm32S = 30
  case ecEarth3pHr = 31
  case mpiEsm12Xr = 32
  case nicam168s = 33
  case era5 = 34
  case cerra = 35
  case era5Land = 36
  case ecmwfIfs = 37
  case glofasSeamlessV3 = 38
  case glofasForecastV3 = 39
  case glofasConsolidatedV3 = 40
  case glofasSeamlessV4 = 41
  case glofasForecastV4 = 42
  case glofasConsolidatedV4 = 43
  case gwam = 44
  case ewam = 45
  case noaaCfs = 46

  public static var max: com_openmeteo_api_result_Model { return .noaaCfs }
  public static var min: com_openmeteo_api_result_Model { return .undefined }
}


public struct com_openmeteo_api_result_CurrentWeather: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }

  private var _time: Int64
  private var _temperature: Float32
  private var _weathercode: Float32
  private var _windspeed: Float32
  private var _winddirection: Float32
  private var _isDay: Float32
  private let padding0__: UInt32 = 0

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _time = _accessor.readBuffer(of: Int64.self, at: 0)
    _temperature = _accessor.readBuffer(of: Float32.self, at: 8)
    _weathercode = _accessor.readBuffer(of: Float32.self, at: 12)
    _windspeed = _accessor.readBuffer(of: Float32.self, at: 16)
    _winddirection = _accessor.readBuffer(of: Float32.self, at: 20)
    _isDay = _accessor.readBuffer(of: Float32.self, at: 24)
  }

  public init(time: Int64, temperature: Float32, weathercode: Float32, windspeed: Float32, winddirection: Float32, isDay: Float32) {
    _time = time
    _temperature = temperature
    _weathercode = weathercode
    _windspeed = windspeed
    _winddirection = winddirection
    _isDay = isDay
  }

  public init() {
    _time = 0
    _temperature = 0.0
    _weathercode = 0.0
    _windspeed = 0.0
    _winddirection = 0.0
    _isDay = 0.0
  }

  public var time: Int64 { _time }
  public var temperature: Float32 { _temperature }
  public var weathercode: Float32 { _weathercode }
  public var windspeed: Float32 { _windspeed }
  public var winddirection: Float32 { _winddirection }
  public var isDay: Float32 { _isDay }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: com_openmeteo_api_result_CurrentWeather.self)
  }
}

public struct com_openmeteo_api_result_CurrentWeather_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var time: Int64 { return _accessor.readBuffer(of: Int64.self, at: 0) }
  public var temperature: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  public var weathercode: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
  public var windspeed: Float32 { return _accessor.readBuffer(of: Float32.self, at: 16) }
  public var winddirection: Float32 { return _accessor.readBuffer(of: Float32.self, at: 20) }
  public var isDay: Float32 { return _accessor.readBuffer(of: Float32.self, at: 24) }
}

public struct com_openmeteo_api_result_Variable: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case values = 4
    case variable = 6
    case aggregation = 8
    case unit = 10
    case ensembleMember = 12
    case model = 14
    case altitude = 16
    case pressure = 18
    case depth = 20
    case depthUpper = 22
    case gddBase = 24
    case gddLimit = 26
    case inclination = 28
    case facing = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var values: [Float32] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public var variable: com_openmeteo_api_result_VariableType { let o = _accessor.offset(VTOFFSET.variable.v); return o == 0 ? .undefined : com_openmeteo_api_result_VariableType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var aggregation: com_openmeteo_api_result_Aggregation { let o = _accessor.offset(VTOFFSET.aggregation.v); return o == 0 ? .undefined : com_openmeteo_api_result_Aggregation(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var unit: com_openmeteo_api_result_Unit { let o = _accessor.offset(VTOFFSET.unit.v); return o == 0 ? .dimensionless : com_openmeteo_api_result_Unit(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .dimensionless }
  public var ensembleMember: Int32 { let o = _accessor.offset(VTOFFSET.ensembleMember.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var model: com_openmeteo_api_result_Model { let o = _accessor.offset(VTOFFSET.model.v); return o == 0 ? .undefined : com_openmeteo_api_result_Model(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var altitude: Int32 { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var pressure: Int32 { let o = _accessor.offset(VTOFFSET.pressure.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var depth: Int32 { let o = _accessor.offset(VTOFFSET.depth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var depthUpper: Int32 { let o = _accessor.offset(VTOFFSET.depthUpper.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var gddBase: Int32 { let o = _accessor.offset(VTOFFSET.gddBase.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var gddLimit: Int32 { let o = _accessor.offset(VTOFFSET.gddLimit.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var inclination: Int32 { let o = _accessor.offset(VTOFFSET.inclination.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var facing: Int32 { let o = _accessor.offset(VTOFFSET.facing.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startVariable(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func add(variable: com_openmeteo_api_result_VariableType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: variable.rawValue, def: 0, at: VTOFFSET.variable.p) }
  public static func add(aggregation: com_openmeteo_api_result_Aggregation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: aggregation.rawValue, def: 0, at: VTOFFSET.aggregation.p) }
  public static func add(unit: com_openmeteo_api_result_Unit, _ fbb: inout FlatBufferBuilder) { fbb.add(element: unit.rawValue, def: 35, at: VTOFFSET.unit.p) }
  public static func add(ensembleMember: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ensembleMember, def: 0, at: VTOFFSET.ensembleMember.p) }
  public static func add(model: com_openmeteo_api_result_Model, _ fbb: inout FlatBufferBuilder) { fbb.add(element: model.rawValue, def: 0, at: VTOFFSET.model.p) }
  public static func add(altitude: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0, at: VTOFFSET.altitude.p) }
  public static func add(pressure: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pressure, def: 0, at: VTOFFSET.pressure.p) }
  public static func add(depth: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depth, def: 0, at: VTOFFSET.depth.p) }
  public static func add(depthUpper: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depthUpper, def: 0, at: VTOFFSET.depthUpper.p) }
  public static func add(gddBase: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gddBase, def: 0, at: VTOFFSET.gddBase.p) }
  public static func add(gddLimit: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: gddLimit, def: 0, at: VTOFFSET.gddLimit.p) }
  public static func add(inclination: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: inclination, def: 0, at: VTOFFSET.inclination.p) }
  public static func add(facing: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: facing, def: 0, at: VTOFFSET.facing.p) }
  public static func endVariable(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createVariable(
    _ fbb: inout FlatBufferBuilder,
    valuesVectorOffset values: Offset,
    variable: com_openmeteo_api_result_VariableType = .undefined,
    aggregation: com_openmeteo_api_result_Aggregation = .undefined,
    unit: com_openmeteo_api_result_Unit = .dimensionless,
    ensembleMember: Int32 = 0,
    model: com_openmeteo_api_result_Model = .undefined,
    altitude: Int32 = 0,
    pressure: Int32 = 0,
    depth: Int32 = 0,
    depthUpper: Int32 = 0,
    gddBase: Int32 = 0,
    gddLimit: Int32 = 0,
    inclination: Int32 = 0,
    facing: Int32 = 0
  ) -> Offset {
    let __start = com_openmeteo_api_result_Variable.startVariable(&fbb)
    com_openmeteo_api_result_Variable.addVectorOf(values: values, &fbb)
    com_openmeteo_api_result_Variable.add(variable: variable, &fbb)
    com_openmeteo_api_result_Variable.add(aggregation: aggregation, &fbb)
    com_openmeteo_api_result_Variable.add(unit: unit, &fbb)
    com_openmeteo_api_result_Variable.add(ensembleMember: ensembleMember, &fbb)
    com_openmeteo_api_result_Variable.add(model: model, &fbb)
    com_openmeteo_api_result_Variable.add(altitude: altitude, &fbb)
    com_openmeteo_api_result_Variable.add(pressure: pressure, &fbb)
    com_openmeteo_api_result_Variable.add(depth: depth, &fbb)
    com_openmeteo_api_result_Variable.add(depthUpper: depthUpper, &fbb)
    com_openmeteo_api_result_Variable.add(gddBase: gddBase, &fbb)
    com_openmeteo_api_result_Variable.add(gddLimit: gddLimit, &fbb)
    com_openmeteo_api_result_Variable.add(inclination: inclination, &fbb)
    com_openmeteo_api_result_Variable.add(facing: facing, &fbb)
    return com_openmeteo_api_result_Variable.endVariable(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: true, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.variable.p, fieldName: "variable", required: false, type: com_openmeteo_api_result_VariableType.self)
    try _v.visit(field: VTOFFSET.aggregation.p, fieldName: "aggregation", required: false, type: com_openmeteo_api_result_Aggregation.self)
    try _v.visit(field: VTOFFSET.unit.p, fieldName: "unit", required: false, type: com_openmeteo_api_result_Unit.self)
    try _v.visit(field: VTOFFSET.ensembleMember.p, fieldName: "ensembleMember", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.model.p, fieldName: "model", required: false, type: com_openmeteo_api_result_Model.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.pressure.p, fieldName: "pressure", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.depth.p, fieldName: "depth", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.depthUpper.p, fieldName: "depthUpper", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.gddBase.p, fieldName: "gddBase", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.gddLimit.p, fieldName: "gddLimit", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.inclination.p, fieldName: "inclination", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.facing.p, fieldName: "facing", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct com_openmeteo_api_result_VariableSingle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case variable = 4
    case unit = 6
    case value = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var variable: String! { let o = _accessor.offset(VTOFFSET.variable.v); return _accessor.string(at: o) }
  public var variableSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.variable.v) }
  public var unit: com_openmeteo_api_result_Unit { let o = _accessor.offset(VTOFFSET.unit.v); return o == 0 ? .dimensionless : com_openmeteo_api_result_Unit(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .dimensionless }
  public var value: Float32 { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startVariableSingle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(variable: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variable, at: VTOFFSET.variable.p) }
  public static func add(unit: com_openmeteo_api_result_Unit, _ fbb: inout FlatBufferBuilder) { fbb.add(element: unit.rawValue, def: 35, at: VTOFFSET.unit.p) }
  public static func add(value: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: value, def: 0.0, at: VTOFFSET.value.p) }
  public static func endVariableSingle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createVariableSingle(
    _ fbb: inout FlatBufferBuilder,
    variableOffset variable: Offset,
    unit: com_openmeteo_api_result_Unit = .dimensionless,
    value: Float32 = 0.0
  ) -> Offset {
    let __start = com_openmeteo_api_result_VariableSingle.startVariableSingle(&fbb)
    com_openmeteo_api_result_VariableSingle.add(variable: variable, &fbb)
    com_openmeteo_api_result_VariableSingle.add(unit: unit, &fbb)
    com_openmeteo_api_result_VariableSingle.add(value: value, &fbb)
    return com_openmeteo_api_result_VariableSingle.endVariableSingle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.variable.p, fieldName: "variable", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.unit.p, fieldName: "unit", required: false, type: com_openmeteo_api_result_Unit.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: Float32.self)
    _v.finish()
  }
}

public struct com_openmeteo_api_result_Result: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case latitude = 4
    case longitude = 6
    case elevation = 8
    case generationtimeMs = 10
    case utcOffsetSeconds = 12
    case timezone = 14
    case timezoneAbbreviation = 16
    case currentWeather = 18
    case timeStart = 20
    case daily = 22
    case hourly = 24
    case sixHourly = 26
    case minutely15 = 28
    case current = 30
    case currentTime = 32
    case currentIntervalSeconds = 34
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var latitude: Float32 { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var longitude: Float32 { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var elevation: Float32 { let o = _accessor.offset(VTOFFSET.elevation.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var generationtimeMs: Float32 { let o = _accessor.offset(VTOFFSET.generationtimeMs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var utcOffsetSeconds: Int32 { let o = _accessor.offset(VTOFFSET.utcOffsetSeconds.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var timezone: String? { let o = _accessor.offset(VTOFFSET.timezone.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var timezoneSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.timezone.v) }
  public var timezoneAbbreviation: String? { let o = _accessor.offset(VTOFFSET.timezoneAbbreviation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var timezoneAbbreviationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.timezoneAbbreviation.v) }
  public var currentWeather: com_openmeteo_api_result_CurrentWeather? { let o = _accessor.offset(VTOFFSET.currentWeather.v); return o == 0 ? nil : _accessor.readBuffer(of: com_openmeteo_api_result_CurrentWeather.self, at: o) }
  public var mutableCurrentWeather: com_openmeteo_api_result_CurrentWeather_Mutable? { let o = _accessor.offset(VTOFFSET.currentWeather.v); return o == 0 ? nil : com_openmeteo_api_result_CurrentWeather_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var timeStart: Int64 { let o = _accessor.offset(VTOFFSET.timeStart.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var hasDaily: Bool { let o = _accessor.offset(VTOFFSET.daily.v); return o == 0 ? false : true }
  public var dailyCount: Int32 { let o = _accessor.offset(VTOFFSET.daily.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func daily(at index: Int32) -> com_openmeteo_api_result_Variable? { let o = _accessor.offset(VTOFFSET.daily.v); return o == 0 ? nil : com_openmeteo_api_result_Variable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasHourly: Bool { let o = _accessor.offset(VTOFFSET.hourly.v); return o == 0 ? false : true }
  public var hourlyCount: Int32 { let o = _accessor.offset(VTOFFSET.hourly.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func hourly(at index: Int32) -> com_openmeteo_api_result_Variable? { let o = _accessor.offset(VTOFFSET.hourly.v); return o == 0 ? nil : com_openmeteo_api_result_Variable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasSixHourly: Bool { let o = _accessor.offset(VTOFFSET.sixHourly.v); return o == 0 ? false : true }
  public var sixHourlyCount: Int32 { let o = _accessor.offset(VTOFFSET.sixHourly.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func sixHourly(at index: Int32) -> com_openmeteo_api_result_Variable? { let o = _accessor.offset(VTOFFSET.sixHourly.v); return o == 0 ? nil : com_openmeteo_api_result_Variable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasMinutely15: Bool { let o = _accessor.offset(VTOFFSET.minutely15.v); return o == 0 ? false : true }
  public var minutely15Count: Int32 { let o = _accessor.offset(VTOFFSET.minutely15.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func minutely15(at index: Int32) -> com_openmeteo_api_result_Variable? { let o = _accessor.offset(VTOFFSET.minutely15.v); return o == 0 ? nil : com_openmeteo_api_result_Variable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasCurrent: Bool { let o = _accessor.offset(VTOFFSET.current.v); return o == 0 ? false : true }
  public var currentCount: Int32 { let o = _accessor.offset(VTOFFSET.current.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func current(at index: Int32) -> com_openmeteo_api_result_VariableSingle? { let o = _accessor.offset(VTOFFSET.current.v); return o == 0 ? nil : com_openmeteo_api_result_VariableSingle(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var currentTime: Int64 { let o = _accessor.offset(VTOFFSET.currentTime.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var currentIntervalSeconds: Int32 { let o = _accessor.offset(VTOFFSET.currentIntervalSeconds.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 16) }
  public static func add(latitude: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(elevation: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elevation, def: 0.0, at: VTOFFSET.elevation.p) }
  public static func add(generationtimeMs: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: generationtimeMs, def: 0.0, at: VTOFFSET.generationtimeMs.p) }
  public static func add(utcOffsetSeconds: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: utcOffsetSeconds, def: 0, at: VTOFFSET.utcOffsetSeconds.p) }
  public static func add(timezone: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: timezone, at: VTOFFSET.timezone.p) }
  public static func add(timezoneAbbreviation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: timezoneAbbreviation, at: VTOFFSET.timezoneAbbreviation.p) }
  public static func add(currentWeather: com_openmeteo_api_result_CurrentWeather?, _ fbb: inout FlatBufferBuilder) { guard let currentWeather = currentWeather else { return }; fbb.create(struct: currentWeather, position: VTOFFSET.currentWeather.p) }
  public static func add(timeStart: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeStart, def: 0, at: VTOFFSET.timeStart.p) }
  public static func addVectorOf(daily: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: daily, at: VTOFFSET.daily.p) }
  public static func addVectorOf(hourly: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hourly, at: VTOFFSET.hourly.p) }
  public static func addVectorOf(sixHourly: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sixHourly, at: VTOFFSET.sixHourly.p) }
  public static func addVectorOf(minutely15: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: minutely15, at: VTOFFSET.minutely15.p) }
  public static func addVectorOf(current: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: current, at: VTOFFSET.current.p) }
  public static func add(currentTime: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: currentTime, def: 0, at: VTOFFSET.currentTime.p) }
  public static func add(currentIntervalSeconds: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: currentIntervalSeconds, def: 0, at: VTOFFSET.currentIntervalSeconds.p) }
  public static func endResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createResult(
    _ fbb: inout FlatBufferBuilder,
    latitude: Float32 = 0.0,
    longitude: Float32 = 0.0,
    elevation: Float32 = 0.0,
    generationtimeMs: Float32 = 0.0,
    utcOffsetSeconds: Int32 = 0,
    timezoneOffset timezone: Offset = Offset(),
    timezoneAbbreviationOffset timezoneAbbreviation: Offset = Offset(),
    currentWeather: com_openmeteo_api_result_CurrentWeather? = nil,
    timeStart: Int64 = 0,
    dailyVectorOffset daily: Offset = Offset(),
    hourlyVectorOffset hourly: Offset = Offset(),
    sixHourlyVectorOffset sixHourly: Offset = Offset(),
    minutely15VectorOffset minutely15: Offset = Offset(),
    currentVectorOffset current: Offset = Offset(),
    currentTime: Int64 = 0,
    currentIntervalSeconds: Int32 = 0
  ) -> Offset {
    let __start = com_openmeteo_api_result_Result.startResult(&fbb)
    com_openmeteo_api_result_Result.add(latitude: latitude, &fbb)
    com_openmeteo_api_result_Result.add(longitude: longitude, &fbb)
    com_openmeteo_api_result_Result.add(elevation: elevation, &fbb)
    com_openmeteo_api_result_Result.add(generationtimeMs: generationtimeMs, &fbb)
    com_openmeteo_api_result_Result.add(utcOffsetSeconds: utcOffsetSeconds, &fbb)
    com_openmeteo_api_result_Result.add(timezone: timezone, &fbb)
    com_openmeteo_api_result_Result.add(timezoneAbbreviation: timezoneAbbreviation, &fbb)
    com_openmeteo_api_result_Result.add(currentWeather: currentWeather, &fbb)
    com_openmeteo_api_result_Result.add(timeStart: timeStart, &fbb)
    com_openmeteo_api_result_Result.addVectorOf(daily: daily, &fbb)
    com_openmeteo_api_result_Result.addVectorOf(hourly: hourly, &fbb)
    com_openmeteo_api_result_Result.addVectorOf(sixHourly: sixHourly, &fbb)
    com_openmeteo_api_result_Result.addVectorOf(minutely15: minutely15, &fbb)
    com_openmeteo_api_result_Result.addVectorOf(current: current, &fbb)
    com_openmeteo_api_result_Result.add(currentTime: currentTime, &fbb)
    com_openmeteo_api_result_Result.add(currentIntervalSeconds: currentIntervalSeconds, &fbb)
    return com_openmeteo_api_result_Result.endResult(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.elevation.p, fieldName: "elevation", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.generationtimeMs.p, fieldName: "generationtimeMs", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.utcOffsetSeconds.p, fieldName: "utcOffsetSeconds", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.timezone.p, fieldName: "timezone", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.timezoneAbbreviation.p, fieldName: "timezoneAbbreviation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.currentWeather.p, fieldName: "currentWeather", required: false, type: com_openmeteo_api_result_CurrentWeather.self)
    try _v.visit(field: VTOFFSET.timeStart.p, fieldName: "timeStart", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.daily.p, fieldName: "daily", required: false, type: ForwardOffset<Vector<ForwardOffset<com_openmeteo_api_result_Variable>, com_openmeteo_api_result_Variable>>.self)
    try _v.visit(field: VTOFFSET.hourly.p, fieldName: "hourly", required: false, type: ForwardOffset<Vector<ForwardOffset<com_openmeteo_api_result_Variable>, com_openmeteo_api_result_Variable>>.self)
    try _v.visit(field: VTOFFSET.sixHourly.p, fieldName: "sixHourly", required: false, type: ForwardOffset<Vector<ForwardOffset<com_openmeteo_api_result_Variable>, com_openmeteo_api_result_Variable>>.self)
    try _v.visit(field: VTOFFSET.minutely15.p, fieldName: "minutely15", required: false, type: ForwardOffset<Vector<ForwardOffset<com_openmeteo_api_result_Variable>, com_openmeteo_api_result_Variable>>.self)
    try _v.visit(field: VTOFFSET.current.p, fieldName: "current", required: false, type: ForwardOffset<Vector<ForwardOffset<com_openmeteo_api_result_VariableSingle>, com_openmeteo_api_result_VariableSingle>>.self)
    try _v.visit(field: VTOFFSET.currentTime.p, fieldName: "currentTime", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.currentIntervalSeconds.p, fieldName: "currentIntervalSeconds", required: false, type: Int32.self)
    _v.finish()
  }
}

