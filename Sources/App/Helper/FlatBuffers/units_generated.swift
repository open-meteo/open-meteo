// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum com_openmeteo_SiUnit: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case celsius = 1
  case fahrenheit = 2
  case kelvin = 3
  case kmh = 4
  case mph = 5
  case knots = 6
  case ms = 7
  case msNotUnitConverted = 8
  case millimeter = 9
  case centimeter = 10
  case inch = 11
  case feet = 12
  case meter = 13
  case gpm = 14
  case percent = 15
  case hectoPascal = 16
  case pascal = 17
  case degreeDirection = 18
  case wmoCode = 19
  case wattPerSquareMeter = 20
  case kilogramPerSquareMeter = 21
  case gramPerKilogram = 22
  case perSecond = 23
  case second = 24
  case qubicMeterPerQubicMeter = 25
  case qubicMeterPerSecond = 26
  case kiloPascal = 27
  case megaJoulesPerSquareMeter = 28
  case joulesPerKilogram = 29
  case hours = 30
  case iso8601 = 31
  case unixtime = 32
  case microgramsPerQuibicMeter = 33
  case grainsPerQuibicMeter = 34
  case dimensionless = 35
  case dimensionlessInteger = 36
  case eaqi = 37
  case usaqi = 38
  case gddCelsius = 39
  case fraction = 40

  public static var max: com_openmeteo_SiUnit { return .fraction }
  public static var min: com_openmeteo_SiUnit { return .undefined }
}


public struct com_openmeteo_TimeRange: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }

  private var _start: Int64
  private var _end: Int64
  private var _interval: Int32
  private let padding0__: UInt32 = 0

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _start = _accessor.readBuffer(of: Int64.self, at: 0)
    _end = _accessor.readBuffer(of: Int64.self, at: 8)
    _interval = _accessor.readBuffer(of: Int32.self, at: 16)
  }

  public init(start: Int64, end: Int64, interval: Int32) {
    _start = start
    _end = end
    _interval = interval
  }

  public init() {
    _start = 0
    _end = 0
    _interval = 0
  }

  public var start: Int64 { _start }
  public var end: Int64 { _end }
  public var interval: Int32 { _interval }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: com_openmeteo_TimeRange.self)
  }
}

public struct com_openmeteo_TimeRange_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var start: Int64 { return _accessor.readBuffer(of: Int64.self, at: 0) }
  public var end: Int64 { return _accessor.readBuffer(of: Int64.self, at: 8) }
  public var interval: Int32 { return _accessor.readBuffer(of: Int32.self, at: 16) }
}

public struct com_openmeteo_ValueAndUnit: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }

  private var _value: Float32
  private var _unit: Int8
  private let padding0__: UInt8 = 0
  private let padding1__: UInt16 = 0

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _value = _accessor.readBuffer(of: Float32.self, at: 0)
    _unit = _accessor.readBuffer(of: Int8.self, at: 4)
  }

  public init(value: Float32, unit: com_openmeteo_SiUnit) {
    _value = value
    _unit = unit.value
  }

  public init() {
    _value = 0.0
    _unit = 0
  }

  public var value: Float32 { _value }
  public var unit: com_openmeteo_SiUnit { com_openmeteo_SiUnit(rawValue: _unit)! }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: com_openmeteo_ValueAndUnit.self)
  }
}

public struct com_openmeteo_ValueAndUnit_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var value: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  public var unit: com_openmeteo_SiUnit { return com_openmeteo_SiUnit(rawValue: _accessor.readBuffer(of: Int8.self, at: 4)) ?? .undefined }
}

public struct com_openmeteo_ValuesAndUnit: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case values = 4
    case unit = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var values: [Float32] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public var unit: com_openmeteo_SiUnit { let o = _accessor.offset(VTOFFSET.unit.v); return o == 0 ? .undefined : com_openmeteo_SiUnit(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public static func startValuesAndUnit(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func add(unit: com_openmeteo_SiUnit, _ fbb: inout FlatBufferBuilder) { fbb.add(element: unit.rawValue, def: 0, at: VTOFFSET.unit.p) }
  public static func endValuesAndUnit(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createValuesAndUnit(
    _ fbb: inout FlatBufferBuilder,
    valuesVectorOffset values: Offset,
    unit: com_openmeteo_SiUnit = .undefined
  ) -> Offset {
    let __start = com_openmeteo_ValuesAndUnit.startValuesAndUnit(&fbb)
    com_openmeteo_ValuesAndUnit.addVectorOf(values: values, &fbb)
    com_openmeteo_ValuesAndUnit.add(unit: unit, &fbb)
    return com_openmeteo_ValuesAndUnit.endValuesAndUnit(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: true, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.unit.p, fieldName: "unit", required: false, type: com_openmeteo_SiUnit.self)
    _v.finish()
  }
}

